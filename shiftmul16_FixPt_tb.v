// -------------------------------------------------------------
//
// Module: shiftmul16_FixPt_tb_pac
// Path: G:\AI\IIT BHU\codegen\shiftmul16\hdlsrc
// Created: 2016-06-07 17:04:06
// Generated by MATLAB 8.1, MATLAB Coder 2.4 and HDL Coder 3.2
// 
// Description: test bench tasks, parameters
//
//
// -------------------------------------------------------------
`timescale 1 ns / 1 ns 

module shiftmul16_FixPt_tb;

  task b1_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =   1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // b1_task

  task b2_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =   1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // b2_task

  task b3_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =   1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // b3_task

  task b4_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =   1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // b4_task

  task b5_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =   1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // b5_task

  task b6_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =   1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // b6_task

  task b7_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =   1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // b7_task

  task b8_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =   1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // b8_task

  task y1_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =  #1  1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // y1_task

  task y3_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =  #1  1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // y3_task

  task y5_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =  #1  1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // y5_task

  task y7_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =  #1  1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // y7_task

  task y9_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =  #1  1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // y9_task

  task y11_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =  #1  1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // y11_task

  task y13_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =  #1  1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // y13_task

  task y15_task; 
    input   clk;
    input   reset;
    input   rdenb;
    inout   addr;
    output  done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 1) 
          addr = addr; 
        else
            addr =  #1  1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
  else if (rdenb == 1)
      done = 1; 
    else
      done = 0; 

  end
  endtask // y15_task

 // Constants
 parameter clk_high                         = 5;
 parameter clk_low                          = 5;
 parameter clk_period                       = 10;
 parameter clk_hold                         = 2;
// -------------------------------------------------------------
//
// Module: shiftmul16_FixPt_tb_data
// Path: G:\AI\IIT BHU\codegen\shiftmul16\hdlsrc
// Created: 2016-06-07 17:04:06
// Generated by MATLAB 8.1, MATLAB Coder 2.4 and HDL Coder 3.2
// 
// Description: test bench data
//
//
// -------------------------------------------------------------
  reg  [1:0] b1_force ;
  reg  [1:0] b2_force ;
  reg  [1:0] b3_force ;
  reg  [1:0] b4_force ;
  reg  [1:0] b5_force ;
  reg  [1:0] b6_force ;
  reg  [1:0] b7_force ;
  reg  [1:0] b8_force ;
  reg  [7:0] y1_expected ;
  reg  [3:0] y3_expected ;
  reg  [6:0] y5_expected ;
  reg  signed [2:0] y7_expected ;
  reg  [5:0] y9_expected ;
  reg  [7:0] y11_expected ;
  reg  [7:0] y13_expected ;
  reg  [5:0] y15_expected ;


// **************************************
  initial //Input & Output data
  begin

  // Input data for b1
  b1_force <= 2'h2;

  // Input data for b2
  b2_force <= 2'h2;

  // Input data for b3
  b3_force <= 2'h2;

  // Input data for b4
  b4_force <= 2'h2;

  // Input data for b5
  b5_force <= 2'h2;

  // Input data for b6
  b6_force <= 2'h2;

  // Input data for b7
  b7_force <= 2'h2;

  // Input data for b8
  b8_force <= 2'h2;

  // Output data for y1
  y1_expected <= 8'h08;

  // Output data for y3
  y3_expected <= 4'h4;

  // Output data for y5
  y5_expected <= 7'h04;

  // Output data for y7
  y7_expected <= 3'h4;

  // Output data for y9
  y9_expected <= 6'h00;

  // Output data for y11
  y11_expected <= 8'h04;

  // Output data for y13
  y13_expected <= 8'h04;

  // Output data for y15
  y15_expected <= 6'h04;

  end // Input & Output data
//************************************


// -------------------------------------------------------------
//
// Module: shiftmul16_FixPt_tb
// Path: G:\AI\IIT BHU\codegen\shiftmul16\hdlsrc
// Created: 2016-06-07 17:04:06
// Generated by MATLAB 8.1, MATLAB Coder 2.4 and HDL Coder 3.2
// 
// Hierarchy Level: 1
//
//
// -------------------------------------------------------------
  parameter MAX_TIMEOUT = 2; //uint32
  parameter MAX_ERROR_COUNT = 0; //uint32


 // Signals
  reg  clk; // boolean
  reg  reset; // boolean
  reg   clkenable; // boolean
  reg  [1:0] b1; // ufix2
  reg  [1:0] b2; // ufix2
  reg  [1:0] b3; // ufix2
  reg  [1:0] b4; // ufix2
  reg  [1:0] b5; // ufix2
  reg  [1:0] b6; // ufix2
  reg  [1:0] b7; // ufix2
  reg  [1:0] b8; // ufix2
  wire  ceout; // boolean
  wire [7:0] y1; // uint8
  wire [3:0] y3; // ufix4
  wire [6:0] y5; // ufix7
  wire signed [2:0] y7; // sfix3
  wire [5:0] y9; // ufix6
  wire [7:0] y11; // uint8
  wire [7:0] y13; // uint8
  wire [5:0] y15; // ufix6

  reg  tb_enb; // boolean
  wire srcDone; // boolean
  wire snkDone; // boolean
  wire testFailure; // boolean
  wire tbenb_dly; // boolean
  reg  rdEnb; // boolean
  wire b1_rdenb; // boolean
  reg  b1_addr; // boolean
  reg  b1_done; // boolean
  wire b2_rdenb; // boolean
  reg  b2_addr; // boolean
  reg  b2_done; // boolean
  wire b3_rdenb; // boolean
  reg  b3_addr; // boolean
  reg  b3_done; // boolean
  wire b4_rdenb; // boolean
  reg  b4_addr; // boolean
  reg  b4_done; // boolean
  wire b5_rdenb; // boolean
  reg  b5_addr; // boolean
  reg  b5_done; // boolean
  wire b6_rdenb; // boolean
  reg  b6_addr; // boolean
  reg  b6_done; // boolean
  wire b7_rdenb; // boolean
  reg  b7_addr; // boolean
  reg  b7_done; // boolean
  wire b8_rdenb; // boolean
  reg  b8_addr; // boolean
  reg  b8_done; // boolean
  reg  y1_testFailure; // boolean
  integer y1_timeout; // uint32
  integer y1_errCnt; // uint32
  wire y1_rdenb; // boolean
  reg  y1_addr; // boolean
  reg  y1_done; // boolean
  wire [7:0] y1_ref; // uint8
  reg  check1_Done; // boolean
  reg  y3_testFailure; // boolean
  integer y3_timeout; // uint32
  integer y3_errCnt; // uint32
  wire y3_rdenb; // boolean
  reg  y3_addr; // boolean
  reg  y3_done; // boolean
  wire [3:0] y3_ref; // ufix4
  reg  check2_Done; // boolean
  reg  y5_testFailure; // boolean
  integer y5_timeout; // uint32
  integer y5_errCnt; // uint32
  wire y5_rdenb; // boolean
  reg  y5_addr; // boolean
  reg  y5_done; // boolean
  wire [6:0] y5_ref; // ufix7
  reg  check3_Done; // boolean
  reg  y7_testFailure; // boolean
  integer y7_timeout; // uint32
  integer y7_errCnt; // uint32
  wire y7_rdenb; // boolean
  reg  y7_addr; // boolean
  reg  y7_done; // boolean
  wire signed [2:0] y7_ref; // sfix3
  reg  check4_Done; // boolean
  reg  y9_testFailure; // boolean
  integer y9_timeout; // uint32
  integer y9_errCnt; // uint32
  wire y9_rdenb; // boolean
  reg  y9_addr; // boolean
  reg  y9_done; // boolean
  wire [5:0] y9_ref; // ufix6
  reg  check5_Done; // boolean
  reg  y11_testFailure; // boolean
  integer y11_timeout; // uint32
  integer y11_errCnt; // uint32
  wire y11_rdenb; // boolean
  reg  y11_addr; // boolean
  reg  y11_done; // boolean
  wire [7:0] y11_ref; // uint8
  reg  check6_Done; // boolean
  reg  y13_testFailure; // boolean
  integer y13_timeout; // uint32
  integer y13_errCnt; // uint32
  wire y13_rdenb; // boolean
  reg  y13_addr; // boolean
  reg  y13_done; // boolean
  wire [7:0] y13_ref; // uint8
  reg  check7_Done; // boolean
  reg  y15_testFailure; // boolean
  integer y15_timeout; // uint32
  integer y15_errCnt; // uint32
  wire y15_rdenb; // boolean
  reg  y15_addr; // boolean
  reg  y15_done; // boolean
  wire [5:0] y15_ref; // ufix6
  reg  check8_Done; // boolean
  reg  srcDone_delay; // boolean

 // Module Instances
  shiftmul16_FixPt u_shiftmul16_FixPt
    (
    .clk(clk),
    .reset(reset),
    .clkenable(clkenable),
    .b1(b1),
    .b2(b2),
    .b3(b3),
    .b4(b4),
    .b5(b5),
    .b6(b6),
    .b7(b7),
    .b8(b8),
    .ceout(ceout),
    .y1(y1),
    .y3(y3),
    .y5(y5),
    .y7(y7),
    .y9(y9),
    .y11(y11),
    .y13(y13),
    .y15(y15)
    );


 // Block Statements
  // -------------------------------------------------------------
  // Driving the test bench enable
  // -------------------------------------------------------------

  always @(reset, snkDone)
  begin
    if (reset == 1'b1)
      tb_enb <= 1'b0;
    else if (snkDone == 1'b0 )
      tb_enb <= 1'b1;
    else begin
    # (clk_period * 2);
      tb_enb <= 1'b0;
    end
  end

  always @(posedge clk or posedge reset) // completed_msg
  begin
    if (reset) begin 
       // Nothing to reset.
    end 
    else begin 
      if (snkDone == 1) begin
        if (testFailure == 0)
              $display("**************TEST COMPLETED (PASSED)**************");
        else
              $display("**************TEST COMPLETED (FAILED)**************");
      end
    end
  end // completed_msg;

  // -------------------------------------------------------------
  // System Clock (fast clock) and reset
  // -------------------------------------------------------------

  always  // clock generation
  begin // clk_gen
    clk <= 1'b1;
    # clk_high;
    clk <= 1'b0;
    # clk_low;
    if (snkDone == 1) begin
      clk <= 1'b1;
      # clk_high;
      clk <= 1'b0;
      # clk_low;
      $stop;
    end
  end  // clk_gen

  initial  // reset block
  begin // reset_gen
    reset <= 1'b1;
    # (clk_period * 2);
    @ (posedge clk);
    # (clk_hold);
    reset <= 1'b0;
  end  // reset_gen

  // -------------------------------------------------------------
  // Testbench clock enable
  // -------------------------------------------------------------

  assign tbenb_dly = tb_enb;
  always @(snkDone, tbenb_dly)
  begin
    if (snkDone == 0)
      rdEnb <= tbenb_dly;
    else
      rdEnb <= 0;
  end

  // -------------------------------------------------------------
  // Read the data and transmit it to the DUT
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    b1_task(clk,reset,
            b1_rdenb,b1_addr,
            b1_done);
  end

  assign b1_rdenb = rdEnb;

  always @ (b1_rdenb, b1_addr)
  begin // stimuli_b1_b1
    if (b1_rdenb == 1) begin
      b1 <= # clk_hold b1_force;
    end
  end // stimuli_b1_b1

  // -------------------------------------------------------------
  // Read the data and transmit it to the DUT
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    b2_task(clk,reset,
            b2_rdenb,b2_addr,
            b2_done);
  end

  assign b2_rdenb = rdEnb;

  always @ (b2_rdenb, b2_addr)
  begin // stimuli_b2_b2
    if (b2_rdenb == 1) begin
      b2 <= # clk_hold b2_force;
    end
  end // stimuli_b2_b2

  // -------------------------------------------------------------
  // Read the data and transmit it to the DUT
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    b3_task(clk,reset,
            b3_rdenb,b3_addr,
            b3_done);
  end

  assign b3_rdenb = rdEnb;

  always @ (b3_rdenb, b3_addr)
  begin // stimuli_b3_b3
    if (b3_rdenb == 1) begin
      b3 <= # clk_hold b3_force;
    end
  end // stimuli_b3_b3

  // -------------------------------------------------------------
  // Read the data and transmit it to the DUT
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    b4_task(clk,reset,
            b4_rdenb,b4_addr,
            b4_done);
  end

  assign b4_rdenb = rdEnb;

  always @ (b4_rdenb, b4_addr)
  begin // stimuli_b4_b4
    if (b4_rdenb == 1) begin
      b4 <= # clk_hold b4_force;
    end
  end // stimuli_b4_b4

  // -------------------------------------------------------------
  // Read the data and transmit it to the DUT
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    b5_task(clk,reset,
            b5_rdenb,b5_addr,
            b5_done);
  end

  assign b5_rdenb = rdEnb;

  always @ (b5_rdenb, b5_addr)
  begin // stimuli_b5_b5
    if (b5_rdenb == 1) begin
      b5 <= # clk_hold b5_force;
    end
  end // stimuli_b5_b5

  // -------------------------------------------------------------
  // Read the data and transmit it to the DUT
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    b6_task(clk,reset,
            b6_rdenb,b6_addr,
            b6_done);
  end

  assign b6_rdenb = rdEnb;

  always @ (b6_rdenb, b6_addr)
  begin // stimuli_b6_b6
    if (b6_rdenb == 1) begin
      b6 <= # clk_hold b6_force;
    end
  end // stimuli_b6_b6

  // -------------------------------------------------------------
  // Read the data and transmit it to the DUT
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    b7_task(clk,reset,
            b7_rdenb,b7_addr,
            b7_done);
  end

  assign b7_rdenb = rdEnb;

  always @ (b7_rdenb, b7_addr)
  begin // stimuli_b7_b7
    if (b7_rdenb == 1) begin
      b7 <= # clk_hold b7_force;
    end
  end // stimuli_b7_b7

  // -------------------------------------------------------------
  // Read the data and transmit it to the DUT
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    b8_task(clk,reset,
            b8_rdenb,b8_addr,
            b8_done);
  end

  assign b8_rdenb = rdEnb;

  always @ (b8_rdenb, b8_addr)
  begin // stimuli_b8_b8
    if (b8_rdenb == 1) begin
      b8 <= # clk_hold b8_force;
    end
  end // stimuli_b8_b8

  // -------------------------------------------------------------
  // Create done signal for Input data
  // -------------------------------------------------------------

  assign srcDone = b1_done && b2_done && b3_done && b4_done && b5_done && b6_done && b7_done && b8_done;

  // -------------------------------------------------------------
  //  Checker: Checking the data received from the DUT.
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    y1_task(clk,reset,
            y1_rdenb,y1_addr,
            y1_done);
  end

  assign y1_rdenb = ceout;

  assign y1_ref = y1_expected;


  always @ (posedge clk or posedge reset) // checker_y1
  begin
    if (reset == 1) begin
      y1_timeout <= 0;
      y1_testFailure <= 0;
      y1_errCnt <= 0;
    end 
    else begin 
      if (y1_rdenb == 1 ) begin 
        y1_timeout <= 0;
        if (y1 !== y1_expected) begin
           y1_errCnt <= y1_errCnt + 1;
           y1_testFailure <= 1;
               $display("ERROR in y1 at time %t : Expected '%h' Actual '%h'", 
                    $time, y1_expected, y1);
           if (y1_errCnt >= MAX_ERROR_COUNT) 
             $display("Warning: Number of errors for y1 have exceeded the maximum error limit");
        end

      end
      else if (y1_timeout > MAX_TIMEOUT && y1_rdenb == 1 ) begin 
        y1_errCnt <= y1_errCnt + 1;
        y1_testFailure <= 1;
        $display ("Error: Timeout - Data was not received for y1.");
        $stop;
      end
      else if (y1_rdenb == 1) begin
        y1_timeout <= y1_timeout + 1 ;
      end
    end
  end // checker_y1

  always @ (posedge clk or posedge reset) // checkDone_1
  begin
    if (reset == 1)
      check1_Done <= 0;
    else if ((check1_Done == 0) && (y1_rdenb == 1))
      check1_Done <= 1;
  end

  // -------------------------------------------------------------
  //  Checker: Checking the data received from the DUT.
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    y3_task(clk,reset,
            y3_rdenb,y3_addr,
            y3_done);
  end

  assign y3_rdenb = ceout;

  assign y3_ref = y3_expected;


  always @ (posedge clk or posedge reset) // checker_y3
  begin
    if (reset == 1) begin
      y3_timeout <= 0;
      y3_testFailure <= 0;
      y3_errCnt <= 0;
    end 
    else begin 
      if (y3_rdenb == 1 ) begin 
        y3_timeout <= 0;
        if (y3 !== y3_expected) begin
           y3_errCnt <= y3_errCnt + 1;
           y3_testFailure <= 1;
               $display("ERROR in y3 at time %t : Expected '%h' Actual '%h'", 
                    $time, y3_expected, y3);
           if (y3_errCnt >= MAX_ERROR_COUNT) 
             $display("Warning: Number of errors for y3 have exceeded the maximum error limit");
        end

      end
      else if (y3_timeout > MAX_TIMEOUT && y3_rdenb == 1 ) begin 
        y3_errCnt <= y3_errCnt + 1;
        y3_testFailure <= 1;
        $display ("Error: Timeout - Data was not received for y3.");
        $stop;
      end
      else if (y3_rdenb == 1) begin
        y3_timeout <= y3_timeout + 1 ;
      end
    end
  end // checker_y3

  always @ (posedge clk or posedge reset) // checkDone_2
  begin
    if (reset == 1)
      check2_Done <= 0;
    else if ((check2_Done == 0) && (y3_rdenb == 1))
      check2_Done <= 1;
  end

  // -------------------------------------------------------------
  //  Checker: Checking the data received from the DUT.
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    y5_task(clk,reset,
            y5_rdenb,y5_addr,
            y5_done);
  end

  assign y5_rdenb = ceout;

  assign y5_ref = y5_expected;


  always @ (posedge clk or posedge reset) // checker_y5
  begin
    if (reset == 1) begin
      y5_timeout <= 0;
      y5_testFailure <= 0;
      y5_errCnt <= 0;
    end 
    else begin 
      if (y5_rdenb == 1 ) begin 
        y5_timeout <= 0;
        if (y5 !== y5_expected) begin
           y5_errCnt <= y5_errCnt + 1;
           y5_testFailure <= 1;
               $display("ERROR in y5 at time %t : Expected '%h' Actual '%h'", 
                    $time, y5_expected, y5);
           if (y5_errCnt >= MAX_ERROR_COUNT) 
             $display("Warning: Number of errors for y5 have exceeded the maximum error limit");
        end

      end
      else if (y5_timeout > MAX_TIMEOUT && y5_rdenb == 1 ) begin 
        y5_errCnt <= y5_errCnt + 1;
        y5_testFailure <= 1;
        $display ("Error: Timeout - Data was not received for y5.");
        $stop;
      end
      else if (y5_rdenb == 1) begin
        y5_timeout <= y5_timeout + 1 ;
      end
    end
  end // checker_y5

  always @ (posedge clk or posedge reset) // checkDone_3
  begin
    if (reset == 1)
      check3_Done <= 0;
    else if ((check3_Done == 0) && (y5_rdenb == 1))
      check3_Done <= 1;
  end

  // -------------------------------------------------------------
  //  Checker: Checking the data received from the DUT.
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    y7_task(clk,reset,
            y7_rdenb,y7_addr,
            y7_done);
  end

  assign y7_rdenb = ceout;

  assign y7_ref = y7_expected;


  always @ (posedge clk or posedge reset) // checker_y7
  begin
    if (reset == 1) begin
      y7_timeout <= 0;
      y7_testFailure <= 0;
      y7_errCnt <= 0;
    end 
    else begin 
      if (y7_rdenb == 1 ) begin 
        y7_timeout <= 0;
        if (y7 !== y7_expected) begin
           y7_errCnt <= y7_errCnt + 1;
           y7_testFailure <= 1;
               $display("ERROR in y7 at time %t : Expected '%h' Actual '%h'", 
                    $time, y7_expected, y7);
           if (y7_errCnt >= MAX_ERROR_COUNT) 
             $display("Warning: Number of errors for y7 have exceeded the maximum error limit");
        end

      end
      else if (y7_timeout > MAX_TIMEOUT && y7_rdenb == 1 ) begin 
        y7_errCnt <= y7_errCnt + 1;
        y7_testFailure <= 1;
        $display ("Error: Timeout - Data was not received for y7.");
        $stop;
      end
      else if (y7_rdenb == 1) begin
        y7_timeout <= y7_timeout + 1 ;
      end
    end
  end // checker_y7

  always @ (posedge clk or posedge reset) // checkDone_4
  begin
    if (reset == 1)
      check4_Done <= 0;
    else if ((check4_Done == 0) && (y7_rdenb == 1))
      check4_Done <= 1;
  end

  // -------------------------------------------------------------
  //  Checker: Checking the data received from the DUT.
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    y9_task(clk,reset,
            y9_rdenb,y9_addr,
            y9_done);
  end

  assign y9_rdenb = ceout;

  assign y9_ref = y9_expected;


  always @ (posedge clk or posedge reset) // checker_y9
  begin
    if (reset == 1) begin
      y9_timeout <= 0;
      y9_testFailure <= 0;
      y9_errCnt <= 0;
    end 
    else begin 
      if (y9_rdenb == 1 ) begin 
        y9_timeout <= 0;
        if (y9 !== y9_expected) begin
           y9_errCnt <= y9_errCnt + 1;
           y9_testFailure <= 1;
               $display("ERROR in y9 at time %t : Expected '%h' Actual '%h'", 
                    $time, y9_expected, y9);
           if (y9_errCnt >= MAX_ERROR_COUNT) 
             $display("Warning: Number of errors for y9 have exceeded the maximum error limit");
        end

      end
      else if (y9_timeout > MAX_TIMEOUT && y9_rdenb == 1 ) begin 
        y9_errCnt <= y9_errCnt + 1;
        y9_testFailure <= 1;
        $display ("Error: Timeout - Data was not received for y9.");
        $stop;
      end
      else if (y9_rdenb == 1) begin
        y9_timeout <= y9_timeout + 1 ;
      end
    end
  end // checker_y9

  always @ (posedge clk or posedge reset) // checkDone_5
  begin
    if (reset == 1)
      check5_Done <= 0;
    else if ((check5_Done == 0) && (y9_rdenb == 1))
      check5_Done <= 1;
  end

  // -------------------------------------------------------------
  //  Checker: Checking the data received from the DUT.
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    y11_task(clk,reset,
             y11_rdenb,y11_addr,
             y11_done);
  end

  assign y11_rdenb = ceout;

  assign y11_ref = y11_expected;


  always @ (posedge clk or posedge reset) // checker_y11
  begin
    if (reset == 1) begin
      y11_timeout <= 0;
      y11_testFailure <= 0;
      y11_errCnt <= 0;
    end 
    else begin 
      if (y11_rdenb == 1 ) begin 
        y11_timeout <= 0;
        if (y11 !== y11_expected) begin
           y11_errCnt <= y11_errCnt + 1;
           y11_testFailure <= 1;
               $display("ERROR in y11 at time %t : Expected '%h' Actual '%h'", 
                    $time, y11_expected, y11);
           if (y11_errCnt >= MAX_ERROR_COUNT) 
             $display("Warning: Number of errors for y11 have exceeded the maximum error limit");
        end

      end
      else if (y11_timeout > MAX_TIMEOUT && y11_rdenb == 1 ) begin 
        y11_errCnt <= y11_errCnt + 1;
        y11_testFailure <= 1;
        $display ("Error: Timeout - Data was not received for y11.");
        $stop;
      end
      else if (y11_rdenb == 1) begin
        y11_timeout <= y11_timeout + 1 ;
      end
    end
  end // checker_y11

  always @ (posedge clk or posedge reset) // checkDone_6
  begin
    if (reset == 1)
      check6_Done <= 0;
    else if ((check6_Done == 0) && (y11_rdenb == 1))
      check6_Done <= 1;
  end

  // -------------------------------------------------------------
  //  Checker: Checking the data received from the DUT.
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    y13_task(clk,reset,
             y13_rdenb,y13_addr,
             y13_done);
  end

  assign y13_rdenb = ceout;

  assign y13_ref = y13_expected;


  always @ (posedge clk or posedge reset) // checker_y13
  begin
    if (reset == 1) begin
      y13_timeout <= 0;
      y13_testFailure <= 0;
      y13_errCnt <= 0;
    end 
    else begin 
      if (y13_rdenb == 1 ) begin 
        y13_timeout <= 0;
        if (y13 !== y13_expected) begin
           y13_errCnt <= y13_errCnt + 1;
           y13_testFailure <= 1;
               $display("ERROR in y13 at time %t : Expected '%h' Actual '%h'", 
                    $time, y13_expected, y13);
           if (y13_errCnt >= MAX_ERROR_COUNT) 
             $display("Warning: Number of errors for y13 have exceeded the maximum error limit");
        end

      end
      else if (y13_timeout > MAX_TIMEOUT && y13_rdenb == 1 ) begin 
        y13_errCnt <= y13_errCnt + 1;
        y13_testFailure <= 1;
        $display ("Error: Timeout - Data was not received for y13.");
        $stop;
      end
      else if (y13_rdenb == 1) begin
        y13_timeout <= y13_timeout + 1 ;
      end
    end
  end // checker_y13

  always @ (posedge clk or posedge reset) // checkDone_7
  begin
    if (reset == 1)
      check7_Done <= 0;
    else if ((check7_Done == 0) && (y13_rdenb == 1))
      check7_Done <= 1;
  end

  // -------------------------------------------------------------
  //  Checker: Checking the data received from the DUT.
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    y15_task(clk,reset,
             y15_rdenb,y15_addr,
             y15_done);
  end

  assign y15_rdenb = ceout;

  assign y15_ref = y15_expected;


  always @ (posedge clk or posedge reset) // checker_y15
  begin
    if (reset == 1) begin
      y15_timeout <= 0;
      y15_testFailure <= 0;
      y15_errCnt <= 0;
    end 
    else begin 
      if (y15_rdenb == 1 ) begin 
        y15_timeout <= 0;
        if (y15 !== y15_expected) begin
           y15_errCnt <= y15_errCnt + 1;
           y15_testFailure <= 1;
               $display("ERROR in y15 at time %t : Expected '%h' Actual '%h'", 
                    $time, y15_expected, y15);
           if (y15_errCnt >= MAX_ERROR_COUNT) 
             $display("Warning: Number of errors for y15 have exceeded the maximum error limit");
        end

      end
      else if (y15_timeout > MAX_TIMEOUT && y15_rdenb == 1 ) begin 
        y15_errCnt <= y15_errCnt + 1;
        y15_testFailure <= 1;
        $display ("Error: Timeout - Data was not received for y15.");
        $stop;
      end
      else if (y15_rdenb == 1) begin
        y15_timeout <= y15_timeout + 1 ;
      end
    end
  end // checker_y15

  always @ (posedge clk or posedge reset) // checkDone_8
  begin
    if (reset == 1)
      check8_Done <= 0;
    else if ((check8_Done == 0) && (y15_rdenb == 1))
      check8_Done <= 1;
  end

  // -------------------------------------------------------------
  // Create done and test failure signal for output data
  // -------------------------------------------------------------

  assign snkDone = check1_Done && check2_Done && check3_Done && check4_Done && check5_Done && check6_Done && check7_Done && check8_Done;

  assign testFailure = y1_testFailure || y3_testFailure || y5_testFailure || y7_testFailure || y9_testFailure || y11_testFailure || y13_testFailure || y15_testFailure;

  // -------------------------------------------------------------
  // Global clock enable
  // -------------------------------------------------------------

  always @ (posedge clk or posedge reset)
    begin: srcDone_delay_process
      if (reset == 1'b1) begin
        srcDone_delay <= 1'b0;
      end
      else begin
        if (clkenable == 1'b1) begin
          srcDone_delay <= srcDone;
        end
      end
    end // srcDone_delay_process

  always @(srcDone_delay, rdEnb)
  begin
    if (srcDone_delay == 0)
      # clk_hold clkenable <= rdEnb;
    else
      # clk_hold clkenable <= 0;
  end

 // Assignment Statements



endmodule // shiftmul16_FixPt_tb
